设计模式
一、7大设计原则
设计模式的目的:
代码可重用性、可读性，可扩展性、可靠性、使程序高内聚低耦合

1,单一职责原则
一个类只负责一个功能
2，接口隔离原则
客户端不应该依赖它不需要的接口

3，依赖倒转原则
高层模块不应该依赖于底层模块，两者都应该依赖于抽象
抽象不应该依赖于细节，细节应该依赖抽象
核心:面向接口编程
3种方法传递依赖:接口，构造器，set方法



4，里氏替换
子类尽量不重写父类的方法


5，开闭原则
对扩展开放，对修改关闭


6，迪米特法则
最少知道原则，一个类对自己依赖的类了解越少越好
符合“直接朋友”的类，尽量避免陌生的类


7，合成复用原则
尽量使用合成/聚合的方式，少使用继承
类A用类B的方法，可以将B聚合到A中，耦合性比A继承B要低



二、UML类图的关系
1，类的依赖
泛化(继承)、实现
2，类的关联
聚合(整体和部分可分)、组合(整体和部分不可分)


三、设计模式
提高软件的可维护性、通用性、扩展性
3.1，分为3类，共23种
创建型：单例、工厂、原型、建造者、抽象工厂  5

结构性：适配器、桥接、装饰、组合、外观、享元、代理  7

行为性：模板方法、命令、访问者、迭代器、观察者、中介者、
备忘录、解释器、状态、策略、职责链模式   11

3.2 创建型设计模式
1，单例模式
单例模式注意事项和细节说明
1)单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，
使用单例模式可以提高系统性能
2)当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new
3)单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多
(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象
(比如数据源、session 工厂等)

2，工厂模式
1)工厂模式的意义
将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
2)三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)
3)设计模式的依赖抽象原则
创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。
不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)
不要覆盖基类中已经实现的方法。

3,原型模式
1)创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2)不用重新初始化对象，而是动态地获得对象运行时的状态
3)如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
4)在实现深克隆的时候可能需要比较复杂的代码
5)缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，
需要修改其源代码，违背了 ocp 原则，这点需要注意.

4，建造者模式
1)客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，
使得相同的创建过程可以创建不同的产品对象
2)每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，
 用户使用不同的具体建造者即可得到不同的产品对象
3)可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，
 也更方便使用程序来控制创建过程
4)增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”
5)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，
则不适合使用建造者模式，因此其使用范围受到一定的限制。
6)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，
因此在这种情况下，要考虑是否选择建造者模式.
7)抽象工厂模式 VS 建造者模式
抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，
采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，
它的主要目的是通过组装零配件而产生一个新产品


3.3 结构型设计模式
1，适配器模式
1)三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）
来命名的。
2)类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承
对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有接口适配器：
以接口给到，在 Adapter 里，将 src 作为一个接口，实现
3)Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。
4)实际开发中，实现起来不拘泥于我们讲解的三种经典形式

2，桥接模式
1)实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。
2)对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
3)桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
4)桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5)桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。
桥接模式其它应用场景
对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.

3,装饰器模式





