设计模式
一、7大设计原则
设计模式的目的:
代码可重用性、可读性，可扩展性、可靠性、使程序高内聚低耦合

1,单一职责原则
一个类只负责一个功能
2，接口隔离原则
客户端不应该依赖它不需要的接口

3，依赖倒转原则
高层模块不应该依赖于底层模块，两者都应该依赖于抽象
抽象不应该依赖于细节，细节应该依赖抽象
核心:面向接口编程
3种方法传递依赖:接口，构造器，set方法



4，里氏替换
子类尽量不重写父类的方法


5，开闭原则
对扩展开放，对修改关闭


6，迪米特法则
最少知道原则，一个类对自己依赖的类了解越少越好
符合“直接朋友”的类，尽量避免陌生的类


7，合成复用原则
尽量使用合成/聚合的方式，少使用继承
类A用类B的方法，可以将B聚合到A中，耦合性比A继承B要低



二、UML类图的关系
1，类的依赖
泛化(继承)、实现
2，类的关联
聚合(整体和部分可分)、组合(整体和部分不可分)


三、设计模式
提高软件的可维护性、通用性、扩展性
3.1，分为3类，共23种
创建型：单例、工厂、原型、建造者、抽象工厂  5

结构型：适配器、桥接、装饰、组合、外观、享元、代理  7

行为型：模板方法、命令、访问者、迭代器、观察者、中介者、
备忘录、解释器、状态、策略、职责链模式   11

3.2 创建型设计模式
1，单例模式
单例模式注意事项和细节说明
1)单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，
使用单例模式可以提高系统性能
2)当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new
3)单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多
(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象
(比如数据源、session 工厂等)

2，工厂模式
1)工厂模式的意义
将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
2)三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)
3)设计模式的依赖抽象原则
创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。
不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)
不要覆盖基类中已经实现的方法。

3,原型模式
1)创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2)不用重新初始化对象，而是动态地获得对象运行时的状态
3)如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
4)在实现深克隆的时候可能需要比较复杂的代码
5)缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，
需要修改其源代码，违背了 ocp 原则，这点需要注意.

4，建造者模式
1)客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，
使得相同的创建过程可以创建不同的产品对象
2)每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，
 用户使用不同的具体建造者即可得到不同的产品对象
3)可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，
 也更方便使用程序来控制创建过程
4)增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”
5)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，
则不适合使用建造者模式，因此其使用范围受到一定的限制。
6)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，
因此在这种情况下，要考虑是否选择建造者模式.
7)抽象工厂模式 VS 建造者模式
抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，
采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，
它的主要目的是通过组装零配件而产生一个新产品


3.3 结构型设计模式
1，适配器模式
1)三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）
来命名的。
2)类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承
对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有接口适配器：
以接口给到，在 Adapter 里，将 src 作为一个接口，实现
3)Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。
4)实际开发中，实现起来不拘泥于我们讲解的三种经典形式

2，桥接模式
1)实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。
2)对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
3)桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
4)桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5)桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。
桥接模式其它应用场景
对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.

3,装饰器模式
1)装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，
它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)
2)这里提到的动态的将新功能附加到对象和 ocp 原则，
在后面的应用实例上会以代码的形式体现，请同学们注意体会。

4,组合模式
1)简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
2)具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
3)方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
4)需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.
5)要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式

5,外观模式
1)外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
2)外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展
3)通过合理的使用外观模式，可以帮我们更好的划分访问的层次
4)当系统需要进行分层设计时，可以考虑使用 Facade 模式
5)在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个
Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性
6)不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。

6,享元模式
1)在享元模式这样理解，“享”就表示共享，“元”表示对象
2)系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
3)用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable 存储
4)享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
5)享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.
6)使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
7)享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池

7，代理模式
静态代理优缺点
1)优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展
2)缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类
3)一旦接口增加方法,目标对象与代理对象都要维护

动态代理模式的基本介绍
1)代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
2)代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象
3)动态代理也叫做：JDK 代理、接口代理

Cglib 代理模式的基本介绍
1)静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 Cglib 代理
2)Cglib 代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib 代理归属到动态代理。
3)Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的框架使用,例如 Spring AOP，实现方法拦截
4)在 AOP 编程中如何选择代理模式：
1.目标对象需要实现接口，用 JDK 代理
2.目标对象不需要实现接口，用 Cglib 代理
5)Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类



3.4 行为型设计模式
1，模板方法模式
1)基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改
2)实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。
3)既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。
4)该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大
5)一般模板方法都加上 final 关键字， 防止子类重写模板方法.
6)模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一系列的步骤基本相同，但其个别步骤在实现时 可能不同，通常考虑用模板方法模式来处理

2，命令模式
1)将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
2)容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令
3)容易实现对请求的撤销和重做
4)命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意
5)空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。
6)命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发- 反馈机制

3,访问者模式
优点
1)访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高
2)访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统
缺点
1)具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造成了具体元素变更比较困难
2)违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素
3)因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.




